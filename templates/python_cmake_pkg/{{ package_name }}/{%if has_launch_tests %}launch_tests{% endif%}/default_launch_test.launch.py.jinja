import os
import unittest
import launch
import launch_ros.actions
import launch_testing
from ament_index_python.packages import get_package_share_directory
import pytest

@pytest.mark.launch_test
def generate_test_description():
    launch_file = os.path.join(get_package_share_directory("{{package_name}}"), "launch", "{{node_name}}_launch.py")

    included_launch = launch.actions.IncludeLaunchDescription(
        launch.launch_description_sources.PythonLaunchDescriptionSource(launch_file)
    )

    return (
        launch.LaunchDescription([
            included_launch,
            launch_testing.actions.ReadyToTest()
        ]),
        {'included_launch': included_launch}
    )

class TestDummyWait(unittest.TestCase):
    def test_wait_for_anything(self, proc_output):
        """
        Dummy test: wait for a string that will probably never appear.
        This keeps launch_testing alive for a short period so
        the node under test has time to start (or crash) and flush logs.
        Workaround to sending the send the ReadyToTestsignal delayed via TimerAction which is bugged currently.
        """
        try:
            # Wait for an unlikely string â€“ timeout is expected.
            proc_output.waitFor("___unlikely_string___", timeout=2, stream='stdout')
        except AssertionError:
            self.assertTrue(True)

@launch_testing.post_shutdown_test()
class TestProcessOutput(unittest.TestCase):

    def test_exit_code(self, proc_info):
        # Check that all processes in the launch (in this case, there's just one) exit
        # with code 0
        launch_testing.asserts.assertExitCodes(proc_info)